interface ParamsObject {
    page?: string;
    limit?: boolean | string;
    offset?: boolean | string;
}
declare type Params = ParamsObject | boolean;
export interface FetchPaginateUntilOptions<$Body, Item> {
    page?: $Body;
    response: Response;
    pages: $Body[];
    items: Item[];
    pageItems: Item[];
    responses: Response[];
}
export interface FetchPaginateNextOptions<Item> {
    url: string;
    response?: Response;
    pageItems: Item[];
    firstPage: number;
    firstOffset: number;
    page: number;
    limit?: number;
    offset: number;
    params?: Params;
    isFirst: boolean;
}
interface FetchPaginateNext {
    url?: string;
    limit?: number;
    offset?: number;
    page?: number;
}
export declare type FetchPaginateUntilFunction<$Body, Item> = (untilOptions: FetchPaginateUntilOptions<$Body, Item>) => Promise<boolean> | boolean;
export declare type FetchPaginateItemsFunction<$Body, Item> = (body: $Body) => Item[];
export declare type FetchPaginateMergeFunction<Item> = (setOfSetsOfItems: (Item[] | undefined)[]) => Item[];
export declare type FetchPaginateParseFunction<$Body> = (response: Response) => Promise<$Body> | $Body;
export declare type FetchPaginateNextFunction<Item> = (nextOptions: FetchPaginateNextOptions<Item>) => FetchPaginateNext;
export interface FetchPaginateIteratorValue<$Body, Item> {
    page?: $Body;
    pages: $Body[];
    response: Response;
    responses: Response[];
    pageItems: Item[];
    items: Item[];
}
export interface FetchPaginateGetFetchArgs<$Body, Item> {
    url: string;
    fetchOptions?: ResponseInit;
    offset?: number;
    limit?: number;
    page?: number;
    prev: {
        url: string;
        offset?: number;
        limit?: number;
        page?: number;
        items: Item[];
        pageItems: Item[];
        pageBody?: $Body;
        pages: $Body[];
        response: Response;
        responses: Response[];
    };
}
export interface FetchPaginateOptions<$Body, Item> {
    fetchOptions?: ResponseInit;
    until?: FetchPaginateUntilFunction<$Body, Item>;
    getItems?: FetchPaginateItemsFunction<$Body, Item>;
    merge?: FetchPaginateMergeFunction<Item>;
    parse?: FetchPaginateParseFunction<$Body>;
    next?: FetchPaginateNextFunction<Item>;
    limit?: number;
    offset?: number;
    params?: Params;
    page?: number;
    firstOffset?: number;
    firstPage?: number;
    getFetch?: (args: FetchPaginateGetFetchArgs<$Body, Item>) => typeof fetch;
}
declare const fetchPaginateIterator: <$Body, Item>($url: string | URL, options?: FetchPaginateOptions<$Body, Item>) => {
    getResult: () => {
        items: Item[];
        pages: $Body[];
        responses: Response[];
    };
    [Symbol.asyncIterator]: () => {
        next(): Promise<{
            done: boolean;
            value: FetchPaginateIteratorValue<$Body, Item>;
        }>;
    };
};
declare const fetchPaginate: <$Body, Item>($url: string | URL, options?: FetchPaginateOptions<$Body, Item>) => Promise<{
    items: Item[];
    pages: $Body[];
    responses: Response[];
}>;
export { fetchPaginate, fetchPaginateIterator };
export default fetchPaginate;
